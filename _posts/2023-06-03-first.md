---
layout: single
title:  "VO와 DTO"
author_profiel : false
---

## VO(Value Object)
  VO(Value Object)는 값 자체를 나태내는 객체라는 의미를 갖고 있습니다. 값 자체를 표현하기 때문에 불변객체로 생성해야 하며, setter 같은 성격 변조 가능성이 있는 메소드는 존재하면 안됩니다.또한 두 객체의 주소값이 달라도 같은 값을 담고 있다면 같은 객체로 봐야하기 때문에 hashCode()와 equals()를 오버라이딩하여 반드시 재정의를 해야 합니다.
  
  ```java
    @Getter @Setter
    @Alias("item")
    class ItemVO {
        private Long id;
        private int price;
            private int stockQantity;
        private String category;

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Item item = (Item) o;
            return Objects.equals(id, item.id);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }
    }
  ```

## VO를 사용하는 이유
   * 객체 안에 제약사항을 추가할 수 있습니다.
   
   * 생성될 인스턴스가 정해져 있는 경우 미리 인스턴스를 생성해놓고 캐싱하여 성능을 높일 수 있습니다.

   * Entity의 원시값들을 VO로 포장하면 Entity가 지나치게 거대해지는 것을 막을 수 있어서 테이블 관점이 아닌 객체 지향적인 관점으로 프로그래밍할 수 있습니다.

  \# 제약사항

     - 불변성(Immutable)
       setter와 가변 로직이 없는 불변상태여서 VO를 호출하는 쪽에서는 값을 변경할 수 없습니다.
     - 동등성(Equality)
       객체 주소가 다르더라도 값이 같다면 동등한 객체로 판단합니다.
     - 자가 유효성 검사(Self-Validation)
       모든 유효성 검사는 생성 시간에 이뤄어져야하며, 유효하지 않는 값으로 VO를 생성할 수 없습니다. 따라서 VO를 사용하는 클라이언트는 유효성 검사가 보장되어 있으므로 안전하게 사용할 수 있습니다.
       

## DTO(DATA Transfer Object)
  DTO(DATA Transfer Object)는 Layer(Controller, View, Business Layer)간 데이터 교환하는 객체입니다.

  ![Alt text](../images/2023-06-03-first/dto_1.png)

  로직을 가지고 있는 데이터 객체로, getter/setter 메소드만 가진 클래스를 의미합니다. 또한 어떠한 비즈니스 로직을 가져서는 안되며, 저장, 검색, 직렬화, 역직렬화 로직만을 가져야 합니다.

  아래 코드처럼 setter를 가지는 경우 가변객체로 활용할 수도 있습니다.
```java
  public class MemberDto {
      private String name;
      private int age;

      public String getName() {
          return name;
      }

      public void setName(String name) {
          this.name = name;
      }

      public int getAge() {
          return age;
      }

      public void setAge(int age) {
          this.age = age;
      }
} 
```
이때 setter의 경우 변조 가능성이 있기 때문에 아래와 같이 생성자로 값을 넣어주도록 하게 하면 전달하는 과정에서 변조가 불가능합니다.

```java
  public class MemberDto {
      private final String name;
      private final int age;

      public MemberDto(String name, int age) {
          this.name = name;
          this.age = age;
      }

      public String getName() {
          return name;
      }

      public int getAge() {
          return age;
      }
  }
```

## DTO를 사용하는 이유
  * 객체를 표현하는 계층와 저장하는 계층의 역할을 분리하기 위해서 입니다.

  * Entity 객체를 그대로 사용하면 프로그래머 의도와 다르게 데이터가 변질될 수 있기 때문입니다.

  * 클라이언트와 통신하는 DTO 클래스는 요구사항에 따라 자주 변경됩니다. 즉, 어떠한 특정 값이 추가 되거나 없을 수도 있기 때문입니다.

## DTO vs VO

|*분류*|*DTO*|*VO*|
|----|----|----|
|*정의*|레이어간 데이터 전송용 객체|값 자체 표현|
|*가변성*|가변 또는 불변 객체|불변 객체|
|*로직*|로직을 포함할 수 없다|로직을 포함할 수 있다|
