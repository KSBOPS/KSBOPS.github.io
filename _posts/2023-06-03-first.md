---
layout: single
title:  "VO와 DTO"
author_profiel : false
---

## VO(Value Object)
  VO(Value Object)는 Read-Only속성을 지닌 값 오브젝트로, 값 자체를 나태내는 객체를 의미한다. 값 자체를 표현하기 때문에 불변객체로 생성해야 하며, setter 같은 성격 변조 가능성이 있는 메소드는 존재하면 안된다.


## VO를 사용하는 이유
   * 객체 안에 제약사항을 추가할 수 있다.
   
   * 생성될 인스턴스가 정해져 있는 경우 미리 인스턴스를 생성해놓고 캐싱하여 성능을 높일 수 있다.

   * Entity의 원시값들을 VO로 포장하면 Entity가 지나치게 거대해지는 것을 막을 수 있어서 테이블 관점이 아닌 객체 지향적인 관점으로 프로그래밍할 수 있다.

  \# 제약사항

- 불변성(Immutable)

  setter와 가변 로직이 없는 불변상태여서 VO를 호출하는 쪽에서는 값을 변경할 수 없다.

- 동등성(Equality)

  객체 주소가 다르더라도 값이 같다면 동등한 객체로 판단한다.

- 자가 유효성 검사(Self-Validation)

  모든 유효성 검사는 생성 시간에 이루어져야 하며, 유효하지 않는 값으로 VO를 생성할 수 없다. 따라서 VO를 사용하는 클라이언트는 유효성 검사가 보장되어 있으므로 안전하게 사용할 수 있다.
       

## DTO(DATA Transfer Object)
  DTO(DATA Transfer Object)는 Layer(Controller, View, Business Layer)간 데이터 교환하는 객체이다.

  ![Alt text](../images/2023-06-03-first/dto_1.png)

  로직을 가지고 있는 데이터 객체로, getter/setter 메소드만 가진 클래스를 의미한다. 또한 어떠한 비즈니스 로직을 가져서는 안된다.


## DTO를 사용하는 이유
  * 객체를 표현하는 계층와 저장하는 계층의 역할을 분리하기 위해서

  * Entity 객체를 그대로 사용하면 프로그래머 의도와 다르게 데이터가 변질될 수 있기 때문이다.

  * 클라이언트와 통신하는 DTO 클래스는 요구사항에 따라 자주 변경됩니다. 즉, 어떠한 특정 값이 추가 되거나 없을 수도 있기 때문이다.

## 정리

|*분류*|*DTO*|*VO*|
|----|----|----|
|*정의*|레이어간 데이터 전송용 객체|값 자체 표현|
|*가변성*|가변 또는 불변 객체|불변 객체|
|*로직*|로직을 포함할 수 없다|로직을 포함할 수 있다|
